<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../css/bootstrap.4.0.0-beta3.min.css" />
<link href="https://fonts.googleapis.com/css?family=Raleway:800|Merriweather|Roboto:900" rel="stylesheet">
<link href="../../../css/ionicons.2.0.1.min.css" rel="stylesheet">
<link href="../../../css/main.css" rel="stylesheet">
<link href="../../../css/font.css" rel="stylesheet">
<title>Zer0 Degree - The Boolean Satisfiability Problem [S<small>AT</small>] and S<small>AT</small> solvers in 5 mins* (or&nbsp;more) </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112409544-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112409544-1');
</script>


  </head>
  <body>

    <div class="cover-image" style="height:400px;">
    <img src="../../../img/backgrounds/willian-justen-de-vasconcellos-430007.jpg" style="margin-top:-45px" />

    <div class="cover-image-text-wrapper">
    <div class="cover-image-text">
      <h1 id="zeroDegreeLogo">
        <div>Zer0<br />Degree</div><div><sup id="degreeDot">o</sup><br />&nbsp;</div>
      </h1>
      <div id="zeroDegreeNameAndDescription" style="margin-left:20px">
      <h2 id="zeroDegreeName">
        The Website of <br /><a href>Archy Wilhes 魏何</a>
        <a target="_blank" href="http://twitter.com/archywilhes"><i class="social-icon ion-social-twitter"></i></a>
        <a target="_blank" href="http://github.com/archywilhes"><i class="social-icon ion-social-octocat"></i></a>
        <a target="_blank" href="http://instagram.com/oharchy"><i class="social-icon ion-social-instagram"></i></a>
        <a target="_blank" href="http://archy.sh"><i class="social-icon ion-erlenmeyer-flask"></i></a>
      </h2>
      <div id="zeroDegreeDescription">a comp sci fanatic in his early twenties doing start-up stuff<br />
        (since the age of sixteen) instead of going to univ</div>
      </div>
    </div>
    <h2 class="stayCool thickRaleway">
      Stay cool.
    </h2>
    </div>
  </div>
  <div>
    <h2 class="thickRaleway" id="menu">
      <a class="menu-item menu-item-selected">Blog</a>
      <a class="menu-item">Music for Work</a>
      <a class="menu-item">Artwork Info</a>
  </h2>
  </div>
  <article>
    <section class="header">
        Posted on 06 Aug 2015
        
    </section>
    <section>
        <div class="row d_shortcuts">
This is a quick sum-up on (and a beginner guide to) the Boolean Satisfiability Problem.
</div>
<p><small><sup>*</sup>In 5 minutes if one skips the introduction and the words in <i>the Blocks of Grey Text</i>.<br> <a id="blockquoteToggle">Click here to hide the introduction and all <i> Blocks of Grey Text</i>.</a> <br> Word count includes only words <u>not</u> in <i>the Blocks of Grey Text</i>.</small></p>
<div id="introduction">
<h3 id="small0th-minutesmall-introduction-small-classwordcount386nbspwordssmall">
<small>0th minute</small>: Introduction <small class="wordCount">382 words</small>
</h3>
<p>
In CS, when we talk about a <strong>problem</strong>, we are referring to a set of questions, where each question is an instance of the problem. “Is 7 a prime number?” and “Is 2513414231 a prime number?” are both instances of a problem that can be expressed as: “Is n a prime number?”
</p>
<p>
Problems can be classified based on the time or space complexity of the algorithms used to compute an answer for every instance of the problem. Among the most easy-to-understand <strong>NP-complete</strong> problems is the <strong>Boolean Satisfiability Problem</strong> (aka S<small>ATISFIABILITY</small>, or S<small>AT</small>).
</p>
<p>
The <strong>Boolean Satisfiability Problem</strong> is also the first problem proven<sup>{2}</sup> to be NP-complete. A problem is <b>NP-complete</b> if it belongs to the set (or <a href="https://en.wikipedia.org/wiki/Class_(set_theory)">“class”</a> if you prefer) of the hardest problems in <strong>NP</strong> - hardest in the sense that every problem ever exists in NP can be <a href="https://en.wikipedia.org/wiki/Polynomial-time_reduction">reduced</a> to them. (Thus being able to solve a NP-complete problem is equivalent to being able to solve every problem in NP).
</p>
<p class="text-center">
<img style="max-width:400px" src="../../../assets/img/SAT.jpg">
</p>
<blockquote>
<p>
<strong>NP</strong> is the set of decision problems for which there exists a non-deterministic Turing machine that would output a value 1, or 0, after at most O(n<sup>k</sup>) steps where k is some constant and n is the complexity of the input. We often refer to such number of steps (or running time) as polynomial, hence Non-deterministic Polynomial time, or NP.
</p>
<p>
A Turing machine is basically a mathematical object that formalizes that idea of algorithm (<a href="http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf">in Turing model’s of computation</a>). A non-deterministic Turing machine (NDTM) is, in simple words, a theoretical Turing machine that can, in a sense, engage in all possible computations while taking the same time/step as a deterministic Turing machine. (<a href="http://www.encyclopediaofmath.org/index.php/Probabilistic_Turing_machine">Note: nondeterministic doesn’t mean probabilistic.</a>) <b>One way I like to think about a non-deterministic Turing machine is that it can only exist in a universe where time is a 2 dimensional plane.</b> A deterministic Turing machine (DTM) on the other hand computes in one-dimension time (and is defined in terms of a <strong>transition function</strong>, unlike NDTM which relies on a <strong>transition relation</strong>).
</p>
<p>
Besides the Boolean Satisfiability Problem, the prime factorization problem, “Given <span class="math inline"><em>X</em></span> and <span class="math inline"><em>N</em></span>, where <span class="math inline">$1&amp;lt; X &amp;lt; N$</span>, is there a <span class="math inline"><em>d</em></span> where <span class="math inline">$X &amp;lt; d &amp;lt; N$</span> and <span class="math inline"><em>d</em></span> a prime factor of <span class="math inline"><em>N</em></span>?”, is also a problem in <strong>NP</strong>.
</p>
<p>
Decision problems<sup>{1}</sup> are problems concerning only with the “trueness” of some statement. That is to say that algorithms for solving decision problems would output either <code>True</code> or <code>False</code> (often in binary value). The problem above is a decision problem, and so is the problem “Is X a prime number?”
</p>
<p>
I would be diving deeper into computational complexity in an upcoming essay. If you are interested in theoretical CS, I recommend you checking these out:
</p>
<ol>
<li>
<p>
<a href="http://www.amazon.com/gp/product/0521424267/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0521424267&amp;linkCode=as2&amp;tag=0aarhe-20&amp;linkId=PHEETUYVXM6OG77J">Computational Complexity: A Modern Approach</a> (Book)
</p>
</li>
<li>
<p>
<a href="http://www.amazon.com/gp/product/052188473X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=052188473X&amp;linkCode=as2&amp;tag=0aarhe-20&amp;linkId=PDEIBZRCW7SZRZHB">Computational Complexity: A Conceptual Perspective</a> (Book)
</p>
</li>
<li>
<p>
<a href="http://www.amazon.com/gp/product/0716710455/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0716710455&amp;linkCode=as2&amp;tag=0aarhe-20&amp;linkId=SAE3OYM4X44YGLQS">Computers and Intractability: A Guide to the Theory of NP-Completeness</a> (Book)
</p>
</li>
<li>
<p>
<a href="https://complexityzoo.uwaterloo.ca/">Complexity Zoo</a> (Website)
</p>
</li>
<li>
<p>
<a href="https://rjlipton.wordpress.com/">Gödel’s Lost Letter and P=NP</a> (Website)
</p>
</li>
</ol>
</blockquote>
<p>
You can just think of <b>NP</b> as the set of problems whose solution can be <b>verified</b> by an efficient algorithm. And that is different from <b>P</b>, the set of problems whose solution can be <b>found</b> by an efficient algorithm. We can easily prove that each problem in P is also in NP, but we are not sure whether it is true that each problem in NP is too in P.
</p>
<script type="math/tex; mode=display"> (P \subseteq NP) \text{ Duh! }  \\ (NP \subseteq P) \text{ ???? }</script>
<p>
Take the prime factorization problem for example. At the moment the most efficient algorithm <a href="http://www.math.vt.edu/people/brown/doc/briggs_gnfs_thesis.pdf">(for integers larger than 100 digits)</a> we can implement into pre-existing computers<sup>{3}</sup> has a sub-exponential running time. But we can’t say for certainty that the it is not in P. Many brave men and women have tried but failed to come up with a polynomial time algorithm for every instance of the problem. It may simply be the case that we, members of the Human species, are not intelligent enough to design such algorithm. (Or it may be that <span class="math inline">$NP \not= P$</span> and the prime factorization problem is simply not in P, in which case we have yet to prove it.)
</p>
<p>
If we ever come up with an algorithm that can solve all Boolean Satisfiability Problem in polynomial time, it would mean that <span class="math inline"><em>P</em> = <em>N</em><em>P</em></span> since any problem in NP can be reduced into the Boolean Satisfiability Problem. <a href="https://news.ycombinator.com/item?id=2121727">(Here’s a courageous attempt.)</a>
</p>
<blockquote>
<p>
statement<sup>{1}</sup>: More formally, a <strong>decision problem</strong> is defined as a set of strings, <span class="math inline"><em>L</em></span> composed by an alphabet <span class="math inline"><em>Σ</em></span>, where there exists a Turing Machine TM,
</p>
<script type="math/tex; mode=display"> x \in L \Leftrightarrow TM(x) = 1</script>
<p>
So, by the formal definition, <strong>the set of prime numbers is a decision problem</strong>. And this decision problem is known as PRIMES. In 2002, it was <a href="https://www.cs.auckland.ac.nz/~msta039/primality_v6.pdf">proven that PRIMES is in P</a>.
</p>
<p>
Here <span class="math inline"><em>L</em></span> is often referred to as <a href="https://en.wikipedia.org/wiki/Formal_language">a language over <span class="math inline"><em>Σ</em></span></a>.
</p>
<p>
<sup>{2}</sup>: First proven by Cook in his 1971 paper, <a href="https://www.cs.toronto.edu/~sacook/homepage/1971.pdf"><em>The complexity of theorem-proving procedure</em></a>. It was later known as the <a href="https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">Cook–Levin theorem</a>.
</p>
<p>
<sup>{3}</sup>: By “pre-existing computerese I mean classical ones that don’t rely on quantum mechanics (for computation). The most efficient factorization algorithm we know of in the 21st century is the one described in <a href="http://arxiv.org/pdf/quant-ph/9508027v2.pdf">Shor’s 1995 paper</a>, a super-polynomial time algorithm that makes use of <a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform">quantum Fourier transform</a>. The sad (or <a href="https://edwardsnowden.com/2014/01/04/penetrating-hard-targets-and-owning-the-net/">good</a>) news is that there yet exists a quantum computer powerful enough to have <a href="https://en.wikipedia.org/wiki/RSA_problem">any practical uses of the algorithm</a>.
</p>
</blockquote>
</div>
<p>###<small>1st minute</small>: What is the Boolean Satisfiability Problem? <small class="wordCount">334 words</small></p>
<p>The <strong>Boolean Satisfiability Problem</strong> (or S<small>AT</small>) is the problem of determining if a proposition statement<sup>*</sup> is <strong>satisfiable</strong>. A propositional statement is satisfiable when it is possible to assign some true-false values for the variables in the statement such that the statement yields <code>True</code>. Otherwise the statement is unsatisfiable.</p>
<p>A propositional statement is simply a string made up of variables, brackets and these 3 symbols:</p>
<div class="row d_shortcuts text-center">
<p><span class="math inline">¬</span> with the meaning <i>not</i>.<br> $True = False $<br> <span class="math inline">∧</span> with the meaning <i>and</i>.<br> $ False True = False $<br> <span class="math inline">∨</span> with the meaning <i>or</i>.<br> $ False True = True $ <br></p>
</div>
<p>These symbols are also known as logical connectives. They’re arranged in the order of precedence above. Here is an example of a propositional statement:</p>
<p><br /><span class="math display"><em>d</em> ∨ (<em>a</em> ∧ <em>b</em> ∧ (<em>c</em> ∨ <em>d</em> ∧ ¬<em>a</em>))</span><br /></p>
<p>And here is an instance of The Boolean Satisfiability Problem:</p>
<p><br /><span class="math display">Is <em>d</em> ∨ (<em>a</em> ∧ <em>b</em> ∧ (<em>c</em> ∨ <em>d</em> ∧ ¬<em>a</em>)) satisfiable?</span><br /></p>
<p>The answer is yes, it is satisfiable. One solution:</p>
<div class="row d_shortcuts">
<p><span class="math inline"><em>a</em></span> assigned: Any value<br> <span class="math inline"><em>b</em></span> assigned: Any value<br> <span class="math inline"><em>c</em></span> assigned: Any value<br> <span class="math inline"><em>d</em></span> assigned: True<br></p>
</div>
<p>Meanwhile, the answer to the question</p>
<p><br /><span class="math display">Is <em>a</em> ∧ ¬<em>a</em> ∧ <em>b</em> ∧ <em>c</em> ∧ <em>d</em> satisfiable?</span><br /></p>
<p>is no, it is unsatisfiable. That is because there is no value we can assign to <span class="math inline"><em>a</em></span> such that <span class="math inline"><em>a</em> ∧ ¬<em>a</em></span> would yield <code>True</code>, and therefore it is impossible for the entire statement to yield <code>True</code>.</p>
<blockquote>
<p><sup>*</sup>: More technically, it is known as a “formula” or “wff” (“well-formed formula”). “Well-formed” in the sense that it is syntactically correct such that it can be interpreted in our context. “Formula” in the sense that it is something formed by putting symbols together.</p>
<p><br /><span class="math display"><em>w</em><em>f</em><em>f</em> ⊂ <em>s</em><em>t</em><em>a</em><em>t</em><em>e</em><em>m</em><em>e</em><em>n</em><em>t</em></span><br /></p>
<p>“<span class="math inline"> ∧  ∧  ∧ <em>A</em> ∧  ∨ <em>B</em><em>B</em><em>B</em></span>” for example is a statement but not a formula since it is not well-formed.</p>
<p>p.s. In order to know how the symbol works here we rely on its association with the meaning of some lexical item in English, like the word “not” in the case of <span class="math inline">¬</span>, and our intuitive understanding of how “not” functions. We need to keep in mind that the symbols by themselves have no absolute meaning: some are even interpreted differently in different systems of logic (<a href="http://ncatlab.org/nlab/show/classical+logic">classical logic</a> vs <a href="http://ncatlab.org/nlab/show/intuitionistic+logic">intuitionistic logic</a> for example). But that is outside of the scope of this essay, and so for the moment let’s just take it as that these symbols indeed mean what the words mean.</p>
<p>p.s. Often in proposition logic, you would encounter these symbols as well:</p>
<div class="row d_shortcuts text-center">
<span class="math inline">⇒</span> with the meaning <i>imply (if .. then ..) </i>. [<span class="math inline">⇐</span> for different direction]<br> $ (False True) = True $<sup>{4}</sup><br> <span class="math inline">⇔</span> with the meaning <i>if and only if (two-way implication)</i>.<br>$ (False True) = False $
</div>
<p>They are omitted because statements that use these symbols can be rewritten using the basic Boolean operations: <span class="math inline">∨</span>, <span class="math inline">∧</span>, and <span class="math inline">¬</span>.</p>
<p><br /><span class="math display">$$ a \Rightarrow b \text{ can be rewritten as } \neg a \lor b  \\ \text{without changing its satisfiability}$$</span><br /></p>
<p>Since our main concern is satisfiability here, we’d like to be minimalist, and exclude symbols from our alphabet that are not necessary.</p>
<p>p.s. In model theory, we can view the assignment of booleans values to the variables in a statement as <strong>an interpretation</strong> of the statement, and we write</p>
<p><br /><span class="math display"><em>I</em> ⊨ <em>F</em></span><br /></p>
<p>where <span class="math inline"><em>I</em></span> is the interpretation and <span class="math inline"><em>F</em></span> is the statement (or more technically, formula<sup>{1}</sup>) and we say <span class="math inline"><em>I</em></span> is a model of <span class="math inline"><em>F</em></span>. With this in mind, we can say that two formulas <span class="math inline"><em>F</em><sub>1</sub></span> and <span class="math inline"><em>F</em><sub>2</sub></span> are equivalent as long as each model of A is a model of B, and vice versa.</p>
<p><br /><span class="math display"><em>F</em><sub>1</sub> ≡ <em>F</em><sub>2</sub> ⇔ (∀<em>I</em>(<em>I</em> ⊨ <em>F</em><sub>1</sub>) ⇔ (<em>I</em> ⊨ <em>F</em><sub>2</sub>))</span><br /></p>
</blockquote>
<p>S<small>AT</small> is a member of problems known as the <strong>Constraint Satisfaction Problems (or CSPs)</strong>. CSP is basically a generalization of S<small>AT</small>, where the followings are both to be defined:</p>
<ol type="1">
<li><p>the values a variable can be assigned to (often referred to as <em>domain</em>)</p></li>
<li><p>the constraints on what makes a satisfiable statement</p></li>
</ol>
<p>Another member of CSPs is the <a href="http://www.eecs.berkeley.edu/~sseshia/pubdir/SMT-BookChapter.pdf"><strong>Satisfiability Modulo Theories Problem (or SMT)</strong></a>, where, instead of proposition statements (like what we are dealing with in S<small>AT</small>), it is the problem of determining the satisfiability of first-order logic statements, and whether a first-order logic statement is satisfiable depends on the theory of our choice.</p>
<p>Let’s say the theory of our choice is linear arithmetic, we would say that the statement below is satisfiable if variables can take in any value in <span class="math inline">ℝ</span>, the set of real numbers.</p>
<p><br /><span class="math display">2<em>a</em> + 4<em>b</em> = 7</span><br /></p>
<p>It is, however, unsatisfiable if we define <span class="math inline">ℤ</span>, the set of integers, to be the domain instead.</p>
<p class="text-center">
● ● ●
</p>
<p>###Extra <small class="wordCount">(skip this if you want) 213 words</small></p>
<p>When a satisfiable statement always yields <code>True</code> no matter what the value the variables take (every set of true-false assignments to the variables is a solution), we call it a <strong>tautology</strong>. Here is one:</p>
<p><br /><span class="math display"><em>a</em> ∨ ¬<em>a</em></span><br /></p>
<p>Interestingly, the problem of determining if some statement is not a tautology can be easily reduced into the Boolean Satisfiability Problem.</p>
<p>Since a tautology always yields <code>True</code>, negating a tautology would give us a statement that always yields <code>False</code>, and that, my friend, is an unsatisfiable statement. The problem of determining if some statement, V, is not a tautology is thus equivalent to the problem of determining if the negation of the statement, V, is satisfiable. And that means the “Not-Tautology problem” is also in NP.</p>
<p>On the other hand, the Boolean Unsatisfiability Problem is in what’s known as <b>co-NP</b>, and so is the problem of determining if a statement is a tautology.</p>
<p><strong>co-NP</strong> can be thought of as the set of problems whose non-solution can be verified efficiently using a Non-Deterministic Turing Machine. At the moment “NP = co-NP?” remains an open question.</p>
<blockquote>
<p>Formally, a co-NP problem is a language<sup>*</sup> over some alphabet Σ, for which there exists Non-Deterministic Turing Machine that would output 0 in polynomial time, after taking in any string from the language as input.</p>
<p>Note that that is different from a definition of a NP problem, a language<sup>*</sup> for which there exists exists Non-Deterministic Turing Machine that would output 1 in polynomial time, after taking in any string from the language as input.</p>
<p>* : If you are confused by the usage of the word “language”, read {1} (in the <em>block of Grey Text</em>) in 0th minute: Introduction.</p>
<p>All problems in P are in (NP <span class="math inline">∩</span> co-NP). Among other known problems in (NP <span class="math inline">∩</span> co-NP) is the prime factorization problem.</p>
</blockquote>
<p class="text-center">
● ● ●
</p>
<p>From the 2nd minute on we’d be</p>
<ol type="1">
<li><p>using the word <strong>formula</strong> (instead of “statement”) [For the reason, see <sup>{1}</sup> in 1st minute: What is the Boolean Satisfiability Problem? if you haven’t]</p></li>
<li><p>using <strong>S<small>AT</small></strong> as the abbreviation for the Boolean Satisfiability Problem</p></li>
</ol>
<p>###<small>2nd minute:</small> Classifying S<small>AT</small> <small class="wordCount">354 words</small></p>
<p>We can classify instances of S<small>AT</small> based on what form the formulas are in.</p>
<p><strong>3S<small>AT</small></strong> is the instances of S<small>AT</small> where the formulas are in the form</p>
<p><br /><span class="math display">⋀<sub><em>j</em> ∈ <em>J</em></sub>(<em>a</em><sub><em>j</em></sub> ∨ <em>b</em><sub><em>j</em></sub> ∨ <em>c</em><sub><em>j</em></sub>)</span><br /></p>
<p>where <span class="math inline"><em>a</em><sub><em>j</em></sub>, <em>b</em><sub><em>j</em></sub>, <em>c</em><sub><em>j</em></sub></span> are called <strong>literals</strong>. A literal is either an atomic formula or its negation. One example:</p>
<p><br /><span class="math display">(<em>x</em> ∨ ¬<em>y</em> ∨ ¬<em>x</em>) ∧ (<em>x</em> ∨ ¬<em>x</em> ∨ <em>z</em>)</span><br /></p>
<blockquote>
<p>An atomic formula is a formula that has no deeper structure: such as “<span class="math inline"><em>a</em></span>” in “<span class="math inline"><em>a</em> ∧ <em>b</em></span>”.</p>
<p><span class="math inline">⋀</span> works the same as a loop. We can arrive at the formula above by taking $J = \{ 1,2 \} a_1 = a_2 = x, b_1 = y, b_2 = c_1 = x, c_2 = z $.</p>
<p><br /><span class="math display">$$\begin{align} &amp;\bigwedge_{j \in J} ( a_j \lor b_j \lor c_j )  \\ =&amp; ( a_1 \lor b_1 \lor c_1 ) \land ( a_2 \lor b_2 \lor c_2 ) \\ =&amp; ( x \lor \neg y \lor \neg x ) \land ( x \lor \neg x \lor z ) \\ \end{align}$$</span><br /></p>
</blockquote>
<p>This is also known as the <b>Conjunctive<sup>{1}</sup> Normal Form (CNF)</b>. To be more precise, the form above is called <b>3CNF</b> (because it has 3 literals in each clause<sup>{2}</sup>). <b>kCNF</b> is the type of CNF with k number of literals in each clause.</p>
<p><br /><span class="math display">$$\begin{align}  \bigwedge_{j \in J} ( a_j \lor b_j \lor c_j ) &amp;\text{ is 3CNF} \\ \bigwedge_{j \in J} ( a_j \lor b_j) &amp;\text{ is 2CNF}  \end{align}$$</span><br /></p>
<p>More generally, any formula is in CNF as long as it’s of the form:</p>
<p><br /><span class="math display">⋀⋁<em>x</em> is CNF</span><br /></p>
<p>Clauses in a general CNF formula need not contain the same number of literals. Examples:</p>
<p><br /><span class="math display">$$( a \lor b) \land ( c \lor d ) \land (a \lor c \lor b \lor \neg b) \land (\neg a \lor c \lor d) \\ ( a \lor b ) \land c$$</span><br /></p>
<p>Instances of S<small>AT</small> on statements in <strong><em>k</em>CNF</strong> are called <strong><em>k</em>S<small>AT</small></strong>, where <em>k</em> is a natural number. Great thing about 3S<small>AT</small> is that all instances of S<small>AT</small> are <a href="http://web.mit.edu/~neboat/www/6.046-fa09/rec8.pdf">reducible</a> into 3S<small>AT</small>. And that means 3S<small>AT</small> is also NP-complete. <strong>2S<small>AT</small></strong>, on the other hand, is S<small>AT</small> in 2CNF and it is not NP-complete.</p>
<p>2S<small>AT</small> is in P (and <a href="https://en.wikipedia.org/wiki/NL-complete">NL-complete</a>) and not all instances of S<small>AT</small> can be reduced into 2S<small>AT</small> (or else we can conclude that P = NP).</p>
<p>Lastly, we shall talk about <strong>HORN-S<small>AT</small></strong>, instances of S<small>AT</small> with Horn formula. When each clause contains at most 1 positive literal, we call it a <strong>Horn<sup>{3}</sup> formula</strong>. Here are some examples:</p>
<p><br /><span class="math display">$$( a \lor \neg b) \land ( c \lor \neg d ) \land (\neg a \lor \neg c \lor \neg b) \land \neg x \\ x \land y \land z \land (\neg d \lor \neg x \lor \neg i \lor \neg y) \\ ( a \lor \neg b ) \land c$$</span><br /></p>
<div class="text-center">
<p><img style="max-width:300px" src="../../../assets/img/such horn.jpg"></p>
</div>
<p>Not only is Horn-S<small>AT</small> in P (just like 2S<small>AT</small>), it is also <a href="https://en.wikipedia.org/wiki/P-complete">P-complete</a>, and <a href="http://www.sciencedirect.com/science/article/pii/0743106684900141">solvable in linear time</a>. (<a href="http://cs.stackexchange.com/questions/45002/is-horn-sat-in-lin-if-so-why-is-that-not-an-indication-that-p-lin">That doesn’t mean P = LIN though.</a>)</p>
<blockquote>
<p><sup>{1}</sup> Conjunctive since it’s formed by <span class="math inline">∧</span>. It yields <code>False</code> if one of its clauses yields <code>False</code>.</p>
<p><sup>{2}</sup>: Formally a <strong>clause</strong> is defined to be a <strong>disjunction</strong> of literal:</p>
<p>Dejunctive since it’s formed by <span class="math inline">∨</span>. It yields <code>True</code> if one of its literals yields <code>True</code>.</p>
<p><sup>{3}</sup> Initially in propositional logic, a Horn clause is in the form</p>
<p><br /><span class="math display">(⋀<sub><em>a</em> ∈ <em>A</em></sub><em>a</em>) ⇒ <em>b</em></span><br /></p>
<p>In S<small>AT</small>, since we don’t use the <span class="math inline">⇒</span> symbol, the above is re-written as:</p>
<p><br /><span class="math display"><em>b</em> ∨ (⋁<sub><em>a</em> ∈ <em>A</em></sub>¬<em>a</em>)</span><br /></p>
<p>or in the case that <span class="math inline"><em>b</em></span> is an absolute <code>True</code>, we have <span class="math inline">(⋀<sub><em>a</em> ∈ <em>A</em></sub><em>a</em>) ⇒ <em>T</em><em>r</em><em>u</em><em>e</em></span>, which gives us</p>
<p><br /><span class="math display">⋁<sub><em>a</em> ∈ <em>A</em></sub>¬<em>a</em></span><br /></p>
<p>or in the case that <span class="math inline">⋁<sub><em>a</em> ∈ <em>A</em></sub></span> is an absolute <code>True</code>, we have <span class="math inline"><em>T</em><em>r</em><em>u</em><em>e</em> ⇒ <em>b</em></span>, giving us</p>
<p><br /><span class="math display"><em>b</em></span><br /></p>
</blockquote>
<p>This pretty much sums up generally how instances of S<small>AT</small> are classified. If you are interested in classifying S<small>AT</small> in a more ‘hard core’ manner (viewing S<small>AT</small> itself as a classification problem), <a href="http://www.cs.ucc.ie/~osullb/pubs/classification.pdf">check out this 2008 paper by David Devlin and Barry O’Sullivan</a>.</p>
<p>Perhaps you’ve also heard of problems with names like <a href="https://en.wikipedia.org/wiki/MAX-3SAT">MAXS<small>AT</small></a> and <a href="https://en.wikipedia.org/wiki/Sharp-SAT">#S<small>AT</small></a>. Instances of these problems are not really instances of S<small>AT</small>; it’d be more accurate to say that they are variations of S<small>AT</small>. MAXS<small>AT</small> is the problem of finding a boolean assignment satisfying most clauses in a CNF formula, and #S<small>AT</small> is the problem of counting the number of satisfying assignments.</p>
<p>###<small>3rd minute :</small> S<small>AT</small> Solvers - General Overview <small class="wordCount">337 words</small></p>
<p>There are many known algorithms capable of solving some (but not all) instances of S<small>AT</small> pretty efficiently. We often refer to them as <b>S<small>AT</small> solvers</b>. In general they can be classified into <strong>complete</strong> or <strong>incomplete</strong>.</p>
<p>Complete S<small>AT</small> solvers would always return either <code>satisfiable</code> or <code>unsatisfiable</code>. Incomplete S<small>AT</small> solvers, on the other hand, are less reliable - they may be unable to prove unsatisfiability (when it’s impossible for the formula to yield <code>True</code>), or unable to find a solution when the formula is satisfiable - but perhaps a lot more useful in scenarios when the instances of S<small>AT</small> cannot be solved by complete algorithms in reasonable time.</p>
<blockquote>
<p>To make thing simpler S<small>AT</small> solvers normally take in formulas in CNF form encoded in <a href="http://www.satcompetition.org/2009/format-benchmarks2009.html">DIMACS</a> format as inputs. Suppose we have a formula that isn’t in CNF form, we would first <a href="http://stackoverflow.com/a/11582917/2041954">convert it into CNF form</a> before inputting it into a S<small>AT</small> solver.</p>
</blockquote>
<p>To compare the performance between different S<small>AT</small> solvers, we give them a large set of formulas and see how well each performs (e.g. by the total time taken, or number of formulas solved in n-minutes, or using <a href="http://link.springer.com/chapter/10.1007%2F978-3-642-21581-0_25#page-1">a methodology called <em>careful ranking</em></a>). The set of formulas is often referred to as a benchmark instance. A solver previously lost to another solver may do better if different type of benchmark instances are used.</p>
<p>In <a href="http://satcompetition.org/2014/index.shtml">the S<small>AT</small> 2014 competition</a>, <a href="http://fmv.jku.at/lingeling/">Lingeling</a> beat all the other solvers when evaluated using application-type benchmark instances, but lose to <a href="http://www.labri.fr/perso/lsimon/glucose/">glucose</a> when hard-combinatorial-type are used.</p>
<blockquote>
<p>Due to the NP-complete nature of S<small>AT</small>, we can use S<small>AT</small> solvers to solve real world problems in areas like circuit design (for <a href="http://www.cise.ufl.edu/~zhuang/doc/TR-05.pdf">Combinational Equivalence Checking</a>), and artificial intelligence (for <a href="http://users.ics.aalto.fi/rintanen/jussi/papers/Rintanen11aaai.pdf">Automated Planning and Scheduling</a>). Application-type benchmark instances consist of formulas from real world problems.</p>
</blockquote>
<p>Many modern S<small>AT</small> solvers are based on the original <strong>DPLL</strong> algorithm designed in the 60’s. In summary, DPLL is a complete algorithm that works by assigning a variable some boolean value, checks if this breaks the overall satisfiability: if it doesn’t break, pick a new variable, and check again; if it breaks, alters the assigned value and check again (if both True-False values are tried, go back to the previous variable, alter it and check). Repeatedly doing so until we arrive at either one of these two ends:</p>
<ol type="1">
<li><p>All variables are assigned to some boolean value and it does not break the overall satisfiability, and hence the formula is satisfiable.</p></li>
<li><p>No matter what boolean values a set of variables are assigned to, it would break the overall satisfiability, and hence the formula is unsatisfiable.</p></li>
</ol>
<p>###<small>4th and 5th minutes :</small> S<small>AT</small> Solvers - DPLL and More <small class="wordCount">613 words</small></p>
<p>You may have already imagined, DPLL is basically a <a href="https://www.youtube.com/watch?v=bkROCj-BTWE">depth-first search</a>, and that means at its heart it uses <strong>backtracking</strong>, a brute-force-like technique that, rather than checking every single possible solution one by one (which is what’s known as brute-force), it checks possible solutions by compositing part by part in a combinatorial fashion [e.g. building a solution variable by variable as described above], discarding sets of solutions that are deemed invalid by parts.</p>
<blockquote>
<p>In short, <strong>a backtracking algorithm is very similar to a classical brute-force algorithm, except that it is slightly smarter and thus more efficient</strong>. Here is an example. Imagine you are given 9 numbers</p>
<p><br /><span class="math display">4015, 1635, 8744, 1236, 3241, 123, 6126, 142, 13421</span><br /></p>
<p>and your task is to find if there is a set of <span class="math inline"><em>n</em></span> numbers adding up to a prime number <span class="math inline"><em>x</em></span> where <span class="math inline"><em>n</em> &gt; 3</span> and <span class="math inline"><em>x</em> &lt; 14000</span>. One example of an algorithm that uses backtracking would firstly</p>
<ol type="1">
<li><p>form a set of 3 numbers (e.g. first 3 numbers <span class="math inline">4015, 1635, 8744</span>)</p></li>
<li><p>get its sum (in this case <span class="math inline">4015 + 1635 + 8744 = 14394</span> )</p></li>
<li><p>check if it makes sense to go on adding more numbers into this set of 3 numbers.</p></li>
</ol>
<p>In our case <span class="math inline">14394 &gt; 14000</span>, so it makes no sense to go on and we abandon the last number, 8744, in our set, makes a new set of 3 numbers <span class="math inline">4015, 1635, 1236</span>, and do the same thing to check if it makes sense to go on (in this case <span class="math inline">4015 + 1635 + 1236 = 6886</span>). Since it did not exceed the limit of 14000, we continue to</p>
<ol type="1">
<li><p>add a new number into the the set</p></li>
<li><p>get its sum (in this case it didn’t exceed 14000. We can continue)</p></li>
<li><p>now that <span class="math inline"><em>n</em> &gt; 3</span> (we have 4 numbers), we check if it is prime: if not we add more numbers to it (repeat step 1)</p></li>
</ol>
<p>once we exceed the limit we abandon the last number just like before (and hence <em>backtracking</em>)… Keep doing so until we have</p>
<ol type="1">
<li><p>either tried every sensible combination (sum &lt; 14000), but there is no prime</p></li>
<li><p>or we arrive at a solution, a set of numbers that meets our criteria.</p></li>
</ol>
<p>Read up on <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">the Eight queens puzzle</a> and its backtracking algorithm and you’d have a complete grasp of the concept (if you haven’t).</p>
</blockquote>
<p>The other 2 techniques classical DPLL uses are</p>
<ol type="1">
<li><p><strong>pure literal elimination</strong>: The idea is simple. If a literal appears only as positive or negative (but not both, and hence we call it <strong>pure</strong>) in the formula,</p>
<ol type="1">
<li><p>we assign a value to the literal for it to yield <code>True</code>.</p></li>
<li><p>and delete all the clauses which contain it in the formula.</p></li>
</ol>
<blockquote>
<p>This is because since it is pure, we can just make it yield <code>True</code> and it won’t have any other consequence to the overall satisfiable.</p>
<p><br /><span class="math display">(<em>a</em> ∨ <em>b</em> ∨ ¬<em>c</em>) ∧ (<em>a</em> ∨ ¬<em>b</em>) ∧ (<em>b</em> ∨ ¬<em>c</em>)</span><br /></p>
<p>In the formula above, <span class="math inline"><em>a</em></span> and <span class="math inline"><em>c</em></span> are both pure, so we can give <span class="math inline"><em>a</em> = <em>T</em><em>r</em><em>u</em><em>e</em></span> and <span class="math inline"><em>c</em> = <em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span>, and delete all the clauses that contain them. After that we’d end up with no clauses. And that means the formula is satisfiable with</p>
<div class="row d_shortcuts">
<span class="math inline"><em>a</em></span>: True<br> <span class="math inline"><em>b</em></span>: Any value<br> <span class="math inline"><em>c</em></span>: False<br>
</div>
</blockquote></li>
<li><p><strong>unit propagation</strong>: It is obvious that for clauses made up of 1 literal, that 1 literal has to evaluate <code>True</code> for the formula to yield <code>True</code>. Therefore</p>
<ol type="1">
<li><p>we assign a value for the literal to yield <code>True</code></p></li>
<li><p>delete clauses that contains the literal, and instances of it in opposite polarity (the opposite of positive is negative, vice versa).</p></li>
</ol>
<blockquote>
<p>Take this CNF for example:</p>
<p><br /><span class="math display"><em>a</em> ∧ (<em>a</em> ∨ <em>x</em> ∨ <em>y</em>) ∧ (¬<em>a</em> ∨ ¬<em>b</em>) ∧ (<em>c</em> ∨ <em>b</em>) ∧ (<em>d</em> ∨ ¬<em>b</em>)</span><br /></p>
<p>After 1st round of unit propagation, we would have <span class="math inline"><em>a</em> = <em>T</em><em>r</em><em>u</em><em>e</em></span> and, after reduce the original forumla to:</p>
<p><br /><span class="math display">¬<em>b</em> ∧ (<em>c</em> ∨ <em>b</em>) ∧ (<em>d</em> ∨ ¬<em>b</em>)</span><br /></p>
<p>Great! We can do a 2nd round of unit propagation with <span class="math inline">¬<em>b</em></span>: make <span class="math inline"><em>b</em> = <em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span> and reduce it into:</p>
<p><br /><span class="math display"><em>c</em></span><br /></p>
<p>And here we have it, the original formula is satisfiable with</p>
<div class="row d_shortcuts">
<span class="math inline"><em>a</em></span>: True<br> <span class="math inline"><em>b</em></span>: False<br> <span class="math inline"><em>c</em></span>: False<br> <span class="math inline"><em>d</em></span>: Any value<br>
</div>
<p class="text-center">
● ● ●
</p>
<p>When we end up in a situation where there is an <strong>empty clause</strong> (a clause with 0 literals), it indicates that there is a set of variables no matter what value we assign them, we can’t satisfy the formula. And thus it is unsatisfiable.</p>
<p>Here is an example where after one round of unit propagation, we’d have an empty clause, indicating that no matter what values we assign <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, it won’t satisfy the formula.</p>
<p><br /><span class="math display"><em>a</em> ∧ <em>b</em> ∧ (¬<em>b</em> ∨ ¬<em>a</em>) ∧ (<em>c</em> ∨ <em>b</em> ∨ <em>d</em>) ∧ (<em>d</em> ∨ <em>a</em>)</span><br /></p>
</blockquote></li>
</ol>
<p>More technically, we would say that unit propagation and pure literal elimination are used at each <strong>decision level</strong>. We start off at decision level 0, and the decision level increases by 1 each time as we assign a boolean value to a variable.</p>
<blockquote>
<p>We often call such variable “assigned variable”. And that is different from “implied variables”, variables that get their values from pure literal elimination and unit propagation.</p>
</blockquote>
<p>Here is a simple implementation of classical DPLL in Haskell:</p>
<p>{% highlight Haskell %} import Data.List</p>
<p>data Satisfiability = SAT | UNSAT deriving (Eq, Show)</p>
<p>type Literal = Int type Variable = Int type Clause = [Literal]</p>
<p>type VariableAssignement = (Int,Bool)</p>
<p>–extract variable from literal exv :: Literal -&gt; Variable exv l | l &gt; 0 = l | l &lt; 0 = -l</p>
<p>exvWithValue:: Literal -&gt; VariableAssignement exvWithValue l | l &gt; 0 = (l,True) | l &lt; 0 = (-l,False)</p>
<p>assignTrueFor :: [Clause] -&gt; Variable -&gt; [Clause] (assignTrueFor) cnf literal = [ (- literal) <code>delete</code> clause | clause &lt;- cnf, (not $ literal <code>elem</code> clause)]</p>
<p>hasConflict = (elem) []</p>
<p>dpll :: ([Variable], [Clause]) -&gt; [VariableAssignement] -&gt;(Satisfiability,[VariableAssignement]) dpll (vss@(x:vs),cnf) as | hasConflict cnf = (UNSAT,[]) | let (result,list) = enterDecisionLevelWAL x, result == SAT = (result,list) | otherwise = enterDecisionLevelWAL (-x) – enterDecisionLevelWAL: enter Decision Level With Assigned Literal where enterDecisionLevelWAL theVariable = do_up_and_ple (vs, (cnf <code>assignTrueFor</code> theVariable)) (exvWithValue theVariable:as) dpll ([],_) as = (SAT,as)</p>
<p>– do_up_and_ple: do unit propagation &amp;&amp; pure literal elimination do_up_and_ple :: ([Variable], [Clause]) -&gt; [VariableAssignement] -&gt;(Satisfiability,[VariableAssignement]) do_up_and_ple (vs,cnf) as = dpll (vs’,cnf’) as’ where ((vs’,cnf’),as’) = up_and_ple ((vs,cnf),as) up_and_ple x = check_if_ple_gets_same_result (ple x’) x’ where x’ = (up (ple x)) check_if_ple_gets_same_result x previous | x == previous = x | otherwise = up_and_ple x</p>
<p>– pure literal elimination ple ((vs,cnf),as) | length pls == 0 = ((vs,cnf),as) | otherwise = up ((vs’,cnf’),as’) where cnf’ = foldl (assignTrueFor) cnf pls vs’ = vs \ (fmap exv pls) as’ = as ++ (fmap exvWithValue pls) pls = nubBy (==) $ find_pure_literals literals [] literals = concat cnf find_pure_literals (x:xs) o = find_pure_literals xs o’ where o’ | (x <code>elem</code> literals) &amp;&amp; ( -x <code>elem</code> literals) = o | (-x <code>elem</code> literals) = -x:o | otherwise = x:o find_pure_literals [] o = o</p>
<p>– unit propagation up ((vs,cnf),as) | length ucs == 0 = ((vs,cnf),as) | otherwise = up ((vs’,cnf’),as’) where cnf’ = foldl (assignTrueFor) cnf ucs as’ = as ++ (fmap exvWithValue ucs) vs’ = vs \ (fmap exv ucs) ucs = [ x | (x:xs) &lt;- cnf, xs == []]</p>
<p>dpllStart :: ([Variable], [Clause]) -&gt;(Satisfiability,[VariableAssignement]) dpllStart (vs,cnf) = do_up_and_ple (vs, cnf) [] {% endhighlight %}</p>
<p>To run it, simply invoke <code>dpllStart</code> with a parameter in the form <code>([Int], [[Int]])</code></p>
<p><br /><span class="math display">$$ (a \lor b) \land (a \lor c ) \land (c \lor -d) \\ \text{would be ([1,2,3],[[1,2],[1,3],[3,-4]])}$$</span><br /></p>
<p>and it would return either <code>UNSAT</code> with an empty list or <code>SAT</code> with a list of boolean assignments.</p>
<blockquote>
<p>I’ve integrated a parser for parsing CNF formula in <a href="http://www.satcompetition.org/2009/format-benchmarks2009.html">DIMACS format</a> into the implementation above.</p>
<p><a href="https://github.com/0a-/Haskell-DPLL-SAT-Solver">It’s available on GitHub.</a></p>
</blockquote>
<p>Below is DPLL in pseudo-code with JavaScript-like syntax. (I have omitted the array that stores variable assignments.)</p>
<p>{% highlight JavaScript %} function dpll(formula){ if(formula.has(empty_clause)){ return “UNSAT”; }else if(formula.variables.length === 0){ return “SAT”; } var v = formula.variables[0]; formula.variables.shift(); var new_formula = formula; new_formula.assignVariable(v, TRUE); var result = doUPandPLE(new_formula); if(result === “UNSAT”){ formula.assignVariable(v, FALSE); result = do_up_and_ple(formula); } return result; }</p>
<p>function doUPandPLE(f){ //LiteralElmination &amp; UnitPropagation would remove elements in f.variables //as they make changes to the formula do{ f.repeatedlyDo(“PureLiteralElmination”); f.repeatedlyDo(“UnitPropagation”); }while(f.ifDoPureLiteralElminationCanMakeChanges());</p>
<p>return dpll(f); } {% endhighlight %}</p>
<p class="text-center">
● ● ●
</p>
<p>To improve the performance of a S<small>AT</small> solver, we can use a <strong>heuristic function</strong> to determine which variable to assign a boolean value to in each decision (rather than following a fixed order). We often refer to it as a <strong>decision heuristic</strong>. One example is <strong>VSIDS</strong> introduced in <a href="http://www.princeton.edu/~chaff/software.html">CHAFF</a>, a S<small>AT</small> solver that won the 2006’s S<small>AT</small> competition.</p>
<blockquote>
<p>We call something <strong>heuristic</strong> often when there is not much rigorous maths behind it so it does not guaranteed to be optimal or perfect but it works well after some tests and that is the main reason why it is being implemented &amp; used. Usually, a heuristic function (or algorithm) is characterized by being simple, quick and effective.</p>
</blockquote>
<p>The idea of VSIDS is simple: a variable is chosen for each decision according a ranking of these variables that changes over time. Each variable is ranked by its “activity score”, a floating point variable that would plus some constant, <span class="math inline"><em>C</em></span>, every time the variable shows up in a newly generated clause through a process called “conflict clause learning”. Every now and then, activity scores would be divided by another constant, <span class="math inline"><em>N</em></span>, hence shrinking over time, and “decaying” in the sense. For that reason, it is called VSIDS: Variable State Independent Decaying Sum.</p>
<blockquote>
<p>To learn more about VSIDS you can check out <a href="http://arxiv.org/pdf/1506.08905v1.pdf">Understanding VSIDS Branching Heuristics in Conflict-Driven Clause-Learning S<small>AT</small> Solvers</a> and <a href="https://classes.soe.ucsc.edu/cmps217/Fall07/Project/jaeheon/final_paper/final_paper/input-dist-subm.pdf">The Effect of VSIDS on S<small>AT</small> Solver Performance</a>.</p>
<p>Conflict clause learning is a technique that generates an “conflict clause” by using an <a href="https://en.wikipedia.org/wiki/Implication_graph">implication graph</a> that examines how conflict arises after unit propagation. Conflict happens when all literals in a clause are forced to yield <code>False</code> (which is the case when we have an empty clause, if our algorithm deletes False literal). Thus the process above is often referred to as conflict analysis. If you are interested in learning more about it, check out <a href="http://www.msoos.org/2011/05/understanding-implication-graphs/">this great article (with pictures)</a> by <a href="https://github.com/msoos">msoos</a> from <a href="http://www.msoos.org/">Wondering of a S<small>AT</small> geek</a>. Wanna dive deeper? You’d certainly find these papers useful:</p>
<ol type="1">
<li><p><a href="https://www.cs.rochester.edu/u/kautz/papers/learnIjcai.pdf">Understanding the Power of Clause Learning</a></p></li>
<li><p><a href="http://www.cs.princeton.edu/courses/archive/fall13/cos402/readings/SAT_learning_clauses.pdf">Clause Learning in S<small>AT</small></a></p></li>
<li><p><a href="https://www.jair.org/media/1410/live-1410-2304-jair.pdf">Towards Understanding and Harnessing the Potential of Clause Learning</a></p></li>
<li><p><a href="http://www.princeton.edu/~chaff/publication/iccad2001_final.pdf">Efficient Conflict Driven Learning in a Boolean Satisfiability Solver</a>.</p></li>
</ol>
<p>S<small>AT</small> solvers that use such technique are also known as <a href="https://en.wikipedia.org/wiki/Conflict-Driven_Clause_Learning">Conflict-Driven Clause-Learning (CDCL) S<small>AT</small> Solvers</a>.</p>
</blockquote>
<p>Other ways of improving performance of DPLL-based algorithms include</p>
<ol type="1">
<li><p>adding conflict clauses (generated by conflict analysis as described above) into the formula to prevent from getting into the same conflict again.</p></li>
<li><p>implementing unit propagation by using a technique that watches 2 literals at a time, instead of keeping track of all literals, in which case <a href="http://cs.stackexchange.com/q/44924/11573">you’d need to sacrifice pure literal elimination</a>. To learn more read <a href="http://www.princeton.edu/~chaff/publication/DAC2001v56.pdf">this 2001 paper</a>.</p></li>
<li><p>Other than using heuristic for decision as described above, we can use heuristic for backtracking. And that is actually what’s done in many CDCL S<small>AT</small> Solvers.</p>
<blockquote>
<p>Backtracking like the one in classical DPLL is called chronological backtracking. Chronological in the sense that we we simply go back to the previous decision level. In heuristic backtracking, we go back to a decision level (or backtrack point) based on a <strong>heuristic function</strong>. The principal behind it is that we should learn from conflicts and avoid making the mistake of trying out all different variables assignments down a decision level only to find out that all the assignment at that decision level would only lead to unsatisfiability. That is to say that we would rely on the heuristic to help us in figuring out if the boolean assignment at some previous decision level may be a bad pick, and that we should backtrack all the way up.</p>
</blockquote></li>
<li><p>implementing some <em>restart</em> policies, which force the solver to backtrack to decision level 0 (or some other level) when some condition is met. This is to prevent the solver from getting “stuck” at some part of the <a href="http://wiki.lesswrong.com/wiki/Search_space">search space</a> for a long time. To learn more about it, check out <a href="http://users.cecs.anu.edu.au/~jinbo/07-ijcai-restarts.pdf">The Effect of Restarts on the Efficiency of Clause Learning</a> and <a href="ftp://ftp.research.microsoft.com/pub/ejh/drestart.pdf">Dynamic Restart Policies</a>.</p></li>
</ol>
<p>and many and many more.</p>
<p>###End Note - Further reading:</p>
<ol type="1">
<li><p><a href="http://cacm.acm.org/magazines/2014/3/172516-boolean-satisfiability/fulltext">Boolean Satisfiability: Theory and Engineering (2014)</a> <small class="wordCount">755 words</small></p></li>
<li><p><a href="http://cstheory.stackexchange.com/a/6891/30600">Why is 2S<small>AT</small> in P? (a CS.SE post)</a> <small class="wordCount">300+ words</small></p></li>
<li><p><a href="http://www.princeton.edu/~chaff/publication/cade_cav_2002.pdf">The Quest for Efficient Boolean Satisfiability Solvers (2002)</a> <small class="wordCount">~9k words</small></p></li>
<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.489.8416&amp;rep=rep1&amp;type=pdf">The S<small>AT</small> Phase Transition (1994)</a> <small class="wordCount">~5k words</small></p></li>
<li><p><a href="http://www.cs.cornell.edu/gomes/papers/satsolvers-kr-handbook.pdf">Satisfiability Solvers</a> <small class="wordCount">a chapter from <a href="http://www.amazon.com/gp/product/0444522115/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0444522115&linkCode=as2&tag=0aarhe-20&linkId=UZ2R6YMF7HQ6MZSN">Handbook of Knowledge Representation</a></small></p></li>
<li><p><a href="http://www.cs.toronto.edu/~fbacchus/csc2512/Lectures/2013Readings/Skallah_Empirical_Study_SAT_Solvers.pdf">Empirical Study of the Anatomy of Modern Sat Solvers</a> <small class="wordCount">~5k words</small></p></li>
<li><p><a href="http://www.amazon.com/gp/product/1586039296/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1586039296&amp;linkCode=as2&amp;tag=0aarhe-20&amp;linkId=4SB427BUQ5LKHOFJ">Handbook of Satisfiability</a> <small class="wordCount">a book</small></p></li>
<li><p><a href="http://www.cs.toronto.edu/~chechik/courses03/csc2108/algorithms-for-satisfiability.pdf">Algorithms for the Satisfiability Problem: A Survey (1996)</a> <small class="wordCount">~60k words</small></p></li>
<li><p><a href="http://www.amazon.com/gp/product/3319092839/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=3319092839&amp;linkCode=as2&amp;tag=0aarhe-20&amp;linkId=ZKNKEH4TF3DC6R7R">Theory and Applications of Satisfiability Testing - S<small>AT</small> 2014</a> <small class="wordCount">a book</small> <small>Also available on <a href="http://www.springer.com/us/book/9783319092836">springer</a>.</small></p></li>
</ol>
<p>{{page.script}}</p>
    </section>
</article>

  <div class="cover-image" style="height:400px;">
  <img src="../../../img/backgrounds/maarten-van-den-heuvel-346883.jpg" style="margin-top:-20px" />
  <div class="whiteOverlay"></div>
  <div class="cover-image-text-wrapper">
  <div class="cover-image-text">
    <h1 id="zeroDegreeLogo">
      <div>Zer0<br />Degree</div><div><sup id="degreeDot">o</sup><br />&nbsp;</div>
    </h1>
    <div id="zeroDegreeNameAndDescription" style="margin-left:20px">
    <h2 id="zeroDegreeName">
      Handcarfted <small>single-handed by</small> <br /><a href>Archy Wilhes 魏何</a>
      <a style="margin-left:7px" href="https://github.com/archywilhes/zer0.degree">
          <small>vi3w_s0urce <i class="ion-beer"></i></small>
      </a>
    </h2>
    <div id="zeroDegreeDescription">
        Frontend consists of vanilla JS, CSS & HTML with <a href="https://v4-alpha.getbootstrap.com/">Bootstrap</a>  <br />
         Backend written exclusively in Haskell using <a href="https://jaspervdj.be/hakyll/">Hakyll <i class="ion-heart"></a></i>
    </div>
    </div>
  </div>
  <h2 class="stayCool thickRaleway" style="color:rgba(0,0,0,0.9)">
    <a href="mailto:archy@zer0.degree">Stay in touch?</a>
  </h2>
  </div>
  </div>


  </body>
</html>
